# Task ID: 26
# Title: Implementar Operações DELETE
# Status: done
# Dependencies: 22
# Priority: medium
# Description: Desenvolver funções para remover registros com validação de permissões e integridade referencial.
# Details:
Classe DeleteOperations implementada com as seguintes funcionalidades:

1. Exclusão por ID com verificação de existência:
```javascript
async deleteById(tabela, id) {
  if (!id) {
    return { error: { message: 'ID é obrigatório' } }
  }

  try {
    // Verificar se o registro existe
    const { data: existingRecord, error: fetchError } = await supabase
      .from(tabela)
      .select('id')
      .eq('id', id)
      .single()

    if (fetchError || !existingRecord) {
      return { error: { message: 'Registro não encontrado' } }
    }

    // Realizar a exclusão
    const { error } = await supabase
      .from(tabela)
      .delete()
      .eq('id', id)

    if (error) throw error

    return { success: true, error: null }
  } catch (error) {
    console.error(`Erro ao remover registro com ID ${id}:`, error)
    return { 
      success: false, 
      error: { 
        message: error.code === '23503' ? 'Não é possível excluir: existem registros relacionados' : `Erro ao remover registro de ${tabela}` 
      } 
    }
  }
}
```

2. Soft delete (marcar como inativo):
```javascript
async softDelete(tabela, id) {
  if (!id) {
    return { error: { message: 'ID é obrigatório' } }
  }

  try {
    const { data, error } = await supabase
      .from(tabela)
      .update({ ativo: false, atualizado_em: new Date().toISOString() })
      .eq('id', id)
      .select()

    if (error) throw error

    return { success: true, data: data[0], error: null }
  } catch (error) {
    console.error(`Erro ao realizar soft delete do registro com ID ${id}:`, error)
    return { 
      success: false, 
      error: { message: `Erro ao marcar registro de ${tabela} como inativo` } 
    }
  }
}
```

3. Restauração de registros (reativar):
```javascript
async restoreRecord(tabela, id) {
  if (!id) {
    return { error: { message: 'ID é obrigatório' } }
  }

  try {
    const { data, error } = await supabase
      .from(tabela)
      .update({ ativo: true, atualizado_em: new Date().toISOString() })
      .eq('id', id)
      .select()

    if (error) throw error

    return { success: true, data: data[0], error: null }
  } catch (error) {
    console.error(`Erro ao restaurar registro com ID ${id}:`, error)
    return { 
      success: false, 
      error: { message: `Erro ao reativar registro de ${tabela}` } 
    }
  }
}
```

4. Verificação de dependências antes da exclusão:
```javascript
async checkDependencies(tabela, id) {
  // Mapeamento de tabelas e suas dependências
  const dependencyMap = {
    'categorias': ['produtos'],
    'produtos': ['itens_pedido'],
    // Adicionar outras relações conforme necessário
  }

  const dependencies = dependencyMap[tabela] || []
  const results = {}

  try {
    for (const depTable of dependencies) {
      const { count, error } = await supabase
        .from(depTable)
        .select('*', { count: 'exact', head: true })
        .eq(`${tabela.slice(0, -1)}_id`, id)

      if (error) throw error
      results[depTable] = count
    }

    return { success: true, dependencies: results }
  } catch (error) {
    console.error(`Erro ao verificar dependências para ${tabela} ID ${id}:`, error)
    return { 
      success: false, 
      error: { message: 'Erro ao verificar dependências' } 
    }
  }
}
```

5. Exclusão em cascata com validação:
```javascript
async cascadeDelete(tabela, id, options = { force: false }) {
  // Verificar dependências
  const { success, dependencies, error } = await this.checkDependencies(tabela, id)
  
  if (!success) return { error }
  
  // Se houver dependências e não for forçado, retornar erro
  const hasDependencies = Object.values(dependencies).some(count => count > 0)
  if (hasDependencies && !options.force) {
    return {
      success: false,
      error: { 
        message: 'Existem registros dependentes. Use force: true para exclusão em cascata.',
        dependencies
      }
    }
  }
  
  // Iniciar transação para exclusão em cascata
  try {
    // Implementação da exclusão em cascata
    // Código omitido por brevidade
    
    return { success: true }
  } catch (error) {
    console.error(`Erro na exclusão em cascata para ${tabela} ID ${id}:`, error)
    return { 
      success: false, 
      error: { message: 'Erro ao realizar exclusão em cascata' } 
    }
  }
}
```

6. Exclusão múltipla com filtros:
```javascript
async deleteMany(tabela, filtros) {
  if (!filtros || Object.keys(filtros).length === 0) {
    return { error: { message: 'Filtros são obrigatórios para exclusão múltipla' } }
  }

  try {
    let query = supabase.from(tabela).delete()
    
    // Aplicar filtros
    Object.entries(filtros).forEach(([campo, valor]) => {
      query = query.eq(campo, valor)
    })
    
    const { data, error, count } = await query.select()

    if (error) throw error

    return { success: true, count, data, error: null }
  } catch (error) {
    console.error(`Erro ao remover registros com filtros:`, error)
    return { 
      success: false, 
      error: { message: `Erro ao remover registros de ${tabela}` } 
    }
  }
}
```

# Test Strategy:
1. Testar a exclusão de registros existentes
   - Verificar se a exclusão por ID funciona corretamente
   - Testar a exclusão com filtros múltiplos

2. Verificar se a exclusão respeita as constraints de chave estrangeira
   - Testar a verificação de dependências
   - Verificar se a exclusão em cascata funciona corretamente

3. Testar tentativas de exclusão de registros inexistentes
   - Verificar se retorna erro apropriado

4. Verificar se as políticas de RLS estão sendo respeitadas nas exclusões
   - Testar exclusões com diferentes perfis de usuário

5. Testar o soft delete e verificar se os registros marcados como excluídos não aparecem em consultas regulares
   - Verificar se o campo 'ativo' é atualizado corretamente
   - Testar a restauração de registros inativos

6. Testar o tratamento de erros
   - Verificar se erros de banco de dados são tratados adequadamente
   - Testar mensagens de erro personalizadas

7. Testar a exclusão em cascata
   - Verificar se todas as dependências são removidas corretamente
   - Testar o parâmetro force para forçar exclusão em cascata

# Subtasks:
## 1.  [done]
### Dependencies: None
### Description: Implementar exclusão por ID com verificação de existência
### Details:


## 2.  [done]
### Dependencies: None
### Description: Implementar soft delete (marcar como inativo)
### Details:


## 3.  [done]
### Dependencies: None
### Description: Implementar restauração de registros (reativar)
### Details:


## 4.  [done]
### Dependencies: None
### Description: Implementar verificação de dependências antes da exclusão
### Details:


## 5.  [done]
### Dependencies: None
### Description: Implementar exclusão em cascata com validação
### Details:


## 6.  [done]
### Dependencies: None
### Description: Implementar exclusão múltipla com filtros
### Details:


## 7.  [done]
### Dependencies: None
### Description: Implementar tratamento de erros robusto
### Details:


## 8.  [done]
### Dependencies: None
### Description: Implementar logs de auditoria automáticos
### Details:


